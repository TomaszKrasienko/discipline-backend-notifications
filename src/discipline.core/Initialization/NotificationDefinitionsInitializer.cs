using discipline.core.Domain.NotificationDefinitions.Repositories;
using discipline.core.Initialization.Configuration;
using discipline.core.Services.Abstractions;
using discipline.core.Services.Commands;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;

namespace discipline.core.Initialization;

internal sealed class NotificationDefinitionsInitializer(
    IOptions<InitializationOptions> options,
    IServiceProvider serviceProvider) : BackgroundService
{
    private readonly InitializationOptions _options = options.Value;
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        if (_options.Enabled)
        {
            var commands = new List<NewNotificationDefinitionCommand>();
            commands.Add(new NewNotificationDefinitionCommand(Guid.NewGuid(),
                "autogenerated-tasks", "New auto task", "Your tasks has been generated"));
            commands.Add(new NewNotificationDefinitionCommand(Guid.NewGuid(),
                "upcoming-meeting", "Upcoming meeting", "You have {0} minutes to meeting: {1}"));
            foreach (var command in commands)
            {
                await AddNotificationDefinition(command, stoppingToken);
            }
        }
    }

    private async Task AddNotificationDefinition(NewNotificationDefinitionCommand command, CancellationToken cancellationToken)
    {
        using var scope = serviceProvider.CreateScope();
        var repository = scope.ServiceProvider.GetRequiredService<INotificationDefinitionRepository>();
        var service = scope.ServiceProvider.GetRequiredService<INotificationDefinitionsService>();
        var isContextExists = await repository.IsContextExistsAsync(command.Context,
            cancellationToken);
        if (isContextExists)
        {
            await service.AddNotificationDefinitionAsync(command, cancellationToken);
        }
    }
}